# 分布式数据库大作业

分布式数据库的大作业

## 后端

### 数据库

我们首先设计了若干个数据表，且数据表均满足3NF。数据库的设计如下：

* 用户表（users)

|id| username| password | email |
|---|----|----| ----|
|用户id，主键| 用户名，非空| 密码，非空| 用户邮箱，非空|

* 管理员表（admins)

在本次设计中，Admin表和User表具有相同的结构

* 商品表（items）

| id | userId | name | introduction | pictureURL | kind | originalPrice | currentPrice | amount | uploadTime
| --- | ---| ---| ---| ---| ---| ---| ---| ---| ---| 
| 商品id，主键| 用户id，外键 | 商品名，非空| 介绍，非空 | 图片链接地址 | 商品种类 | 原始价格 | 当前价格，非空 | 数量，非空 | 商品上传时间，非空 | 

*  交易表

交易表中的每个属性值都不能为空
| id | goodId | userId | totalPrice | goodsNumber | address | phoneNumber | orderTime | orderState| 
| --- | ---| ---| ---| ---| ---| ---| ---| ---|
| 交易id，主键| 商品id，外键| 用户id，外键| 订单总价| 订货数量 | 收货地址 | 收货电话 | 生成订单时间 | 订单状态 |

* 商品评价表

待定


#### 分片策略

注意到对一般系统来说，商品种类数（因为对同一种商品来说，卖家不同，则其在数据库中的记录也不相同）
会远远多于用户数，因此当系统的规模增大时，商品表更容易成为系统的瓶颈。

## 前端接口

本项目前后端通信的数据格式统一为JSON格式，前端可以通过RESTful格式的API来访问后端资源。
因为后端有些信息需要授权用户才能访问，因此当后端返回登陆要求时，前端需要让用户验证身份并将验证信息提交至后端。
后端之后会返回token，前端需要在以后的请求中将token附在http的请求头中，以便后端验证用户身份。

后端使用了分布式主键的生成算法（snowflake)，因此前端在post数据时并不需要附带id.



### 例子

```
获取所有用户信息
GET http://127.0.0.1:8080/users

获取特定id用户的信息
GET http://127.0.0.1:8080/users/{id}

往数据库中添加一条用户记录
POST http://127.0.0.1:8080/users，其中http的request body为待提交的JSON格式数据

更新一条数据库中的记录

PUT http://127.0.0.1:8080/users/{id}，其中http的request body为待提交的JSON格式数据，该数据既可以为
用户表的全属性（即更新用户所有信息），也可以为用户表的部分属性（即更新用户的部分信息，例如用户名）
```